rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {
  
    // --- Helper Functions ---

    function isAuthenticated() {
      return request.auth != null;
    }

    function isOwner(userId) {
      return isAuthenticated() && request.auth.uid == userId;
    }
    
    // Checks if the user is the 'hostId' listed on the resource
    function isResourceHost() {
       return isAuthenticated() && resource.data.hostId == request.auth.uid;
    }
    
    // Checks if the user is the 'hostId' of the PARENT class
    function isClassHost(classId) {
      return isAuthenticated() && get(/databases/$(database)/documents/classes/$(classId)).data.hostId == request.auth.uid;
    }

    // --- Collection Rules ---

    // USERS
    // Public read needed for leaderboards (to see names/photos)
    // Write STRICTLY limited to the user themselves
    match /users/{userId} {
      allow read: if isAuthenticated();
      allow create: if isAuthenticated() && request.auth.uid == userId;
      allow update: if isOwner(userId) || (isAuthenticated() && request.resource.data.diff(resource.data).affectedKeys().hasOnly(['badges', 'lifetimePoints', 'lastActive']));
      allow delete: if false; // Users cannot delete themselves via client SDK for safety
      

      
      // Redemption History (Private to user)
      match /redemptions/{redemptionId} {
        allow read: if isOwner(userId);
        // Only allow creation if the user IDs match (logic handled in functions/client)
        allow write: if isOwner(userId); 
      }
    }

    // ACCESS CODES (Trainer Verification)
    // Read: unauthenticated allowed (validated during signup before user exists)
    // Write: authenticated users only
    match /accessCodes/{codeId} {
      allow read: if true;
      allow create: if isAuthenticated();
      allow update: if isAuthenticated();
      allow delete: if isAuthenticated();
    }

    // BADGES COLLECTION (Global Library)
    match /badges/{badgeId} {
      allow read: if isAuthenticated();
      allow create: if isAuthenticated(); // Hosts create badges
      allow update, delete: if resource.data.hostId == request.auth.uid;
    }

    // CLASSES
    match /classes/{classId} {
      allow read: if isAuthenticated();
      allow create: if isAuthenticated();
      
      // Update: Host has full control. 
      // Students can ONLY update 'memberIds' to join/leave.
      allow update: if isAuthenticated() && (
        resource.data.hostId == request.auth.uid || 
        request.resource.data.diff(resource.data).affectedKeys().hasOnly(['memberIds'])
      );
      
      // Delete: Only Host
      allow delete: if isAuthenticated() && resource.data.hostId == request.auth.uid;

      // Sub: MEMBERS
      match /members/{memberId} {
        allow read: if isAuthenticated();
        allow create: if isAuthenticated();
        // Update: Member can update their own data; Host can update anyone
        allow update: if isAuthenticated() && (
          request.auth.uid == memberId || 
          isClassHost(classId)
        );
        allow delete: if isAuthenticated() && (request.auth.uid == memberId || isClassHost(classId));
        
        match /history/{historyId} {
            allow read, write: if isAuthenticated() && (request.auth.uid == memberId || isClassHost(classId));
        }
      }
      
      // Sub: ENERGY
      match /energy/{userId} {
        allow read: if isAuthenticated();
        allow write: if isAuthenticated() && request.auth.uid == userId;
      }
      
      match /pulseChecks/{pulseId} {
        allow read: if isAuthenticated();
        // Allow students to add their response (append to 'responses' array)
        allow update: if isAuthenticated() && request.resource.data.diff(resource.data).affectedKeys().hasOnly(['responses']);
        // Allow host to create, delete, and update (for closing/deactivating pulse checks)
        allow create, delete, update: if isClassHost(classId);
      }
      
      // Sub: TOOLS (Buzzer, etc.)
      match /tools/{toolId} {
        allow read: if isAuthenticated();
        
        // Update: Host full; Student can only buzz (cannot change config/status)
        allow update: if isAuthenticated() && (
          isClassHost(classId) ||
          (toolId == 'buzzer' && request.resource.data.status == resource.data.status)
        );
        
        allow create, delete: if isClassHost(classId);
      }

      // Sub: COMMITMENTS
      match /commitments/{commitmentId} {
        allow read: if isAuthenticated();
        allow create: if isAuthenticated();
        allow delete: if isClassHost(classId); // Only host can moderate/delete
      }
    }

    // LEADER GRID CODES (QR Codes)
    match /leader_grid_codes/{codeId} {
      allow read: if isAuthenticated(); // Students need to read to validate code
      
      // Only Host can create/manage codes
      allow create: if isAuthenticated() && request.resource.data.hostId == request.auth.uid;
      allow update: if isAuthenticated() && (
        isResourceHost() || 
        (
          request.resource.data.diff(resource.data).affectedKeys().hasOnly(['currentScans']) &&
          request.resource.data.currentScans == resource.data.currentScans + 1
        )
      );
      
      allow delete: if isResourceHost();

      match /redemptions/{userId} {
        allow read: if isAuthenticated();
        allow write: if isAuthenticated() && request.auth.uid == userId;
      }
    }

    // QUIZZES (Library)
    match /quizzes/{quizId} {
      allow read: if isAuthenticated();
      allow create: if isAuthenticated() && request.resource.data.createdBy == request.auth.uid;
      allow update, delete: if isAuthenticated() && resource.data.createdBy == request.auth.uid;
    }

    // GAMES (QuizBattle active game sessions)
    match /games/{gameId} {
      allow read: if isAuthenticated();
      allow create: if isAuthenticated() && request.resource.data.hostId == request.auth.uid;
      // Host can fully update, students can only update their player score
      allow update: if isAuthenticated() && (
        resource.data.hostId == request.auth.uid ||
        request.resource.data.diff(resource.data).affectedKeys().hasOnly(['players'])
      );
      allow delete: if isAuthenticated() && resource.data.hostId == request.auth.uid;
      
      // Responses subcollection (students submit answers)
      match /responses/{responseId} {
        allow read: if isAuthenticated();
        allow create: if isAuthenticated();
        allow update, delete: if false; // Responses are immutable
      }
    }

    // POLLS
    match /polls/{pollId} {
      allow read: if isAuthenticated();
      allow create: if isAuthenticated();
      allow update, delete: if isResourceHost();
      
      match /votes/{voteId} {
        allow read: if isAuthenticated();
        allow write: if isAuthenticated(); // Students vote
      }
    }
    
    // TIMERS (Tickr)
    match /timers/{timerId} {
      allow read: if isAuthenticated();
      allow create: if isAuthenticated() && request.resource.data.hostId == request.auth.uid;
      allow update, delete: if isResourceHost();
    }
    
    // WORDSTORMS
    match /wordstorms/{stormId} {
      allow read: if isAuthenticated();
      allow create: if isAuthenticated();
      
      // Only Host can archive/update the storm settings
      allow update, delete: if isResourceHost();
      
      match /words/{wordId} {
        allow read: if isAuthenticated();
        allow create: if isAuthenticated(); // Students submit words
        allow delete: if isAuthenticated() && (
            resource.data.userId == request.auth.uid || 
            get(/databases/$(database)/documents/wordstorms/$(stormId)).data.hostId == request.auth.uid
        );
      }
    }

    // PICPICK GALLERIES - SECURE RULES
    match /galleries/{galleryId} {
      allow read: if isAuthenticated();
      // Only creator can create galleries with themselves as host
      allow create: if isAuthenticated() && request.resource.data.hostId == request.auth.uid;
      // Only host can update gallery settings
      allow update: if isAuthenticated() && resource.data.hostId == request.auth.uid;
      // FIXED: Only host can delete (was: any authenticated user)
      allow delete: if isAuthenticated() && resource.data.hostId == request.auth.uid;
      
      match /photos/{photoId} {
        allow read: if isAuthenticated();
        // Any authenticated user can upload photos
        allow create: if isAuthenticated();
        // Only uploader or host can update photos
        allow update: if isAuthenticated() && (
          resource.data.userId == request.auth.uid ||
          get(/databases/$(database)/documents/galleries/$(galleryId)).data.hostId == request.auth.uid
        );
        // FIXED: Only uploader or host can delete (was: any authenticated user)
        allow delete: if isAuthenticated() && (
          resource.data.userId == request.auth.uid || 
          get(/databases/$(database)/documents/galleries/$(galleryId)).data.hostId == request.auth.uid
        );
        
        // Votes subcollection
        match /votes/{voteId} {
          allow read: if isAuthenticated();
          // FIXED: User can only create ONE vote per photo, must include votedAt timestamp
          allow create: if isAuthenticated() && 
            request.auth.uid == voteId &&
            !exists(/databases/$(database)/documents/galleries/$(galleryId)/photos/$(photoId)/votes/$(voteId)) &&
            request.resource.data.votedAt is timestamp;
          // User can delete their own vote OR host can delete any vote
          allow delete: if isAuthenticated() && (
            request.auth.uid == voteId ||
            get(/databases/$(database)/documents/galleries/$(galleryId)).data.hostId == request.auth.uid
          );
        }
      }
    }

    // PARKING LOT
    match /parking_lot/{questionId} {
      allow read: if isAuthenticated();
      allow create: if isAuthenticated();
      
      // Host answers (updates)
      allow update: if isAuthenticated() && 
        get(/databases/$(database)/documents/classes/$(resource.data.classId)).data.hostId == request.auth.uid;
        
      allow delete: if isAuthenticated() && (
        resource.data.userId == request.auth.uid ||
        get(/databases/$(database)/documents/classes/$(resource.data.classId)).data.hostId == request.auth.uid
      );
    }
    
    // --- ALBUMS & WORKBOOKS ---

    // 1. Album Templates (Designers)
    match /album_templates/{templateId} {
      allow read: if isAuthenticated();
      // Only create if you set yourself as designer
      allow create: if isAuthenticated() && request.resource.data.designerId == request.auth.uid;
      // Only update/delete if you are the designer
      allow update, delete: if isAuthenticated() && resource.data.designerId == request.auth.uid;
    }

    // 2. Class Assignments (Trainers)
    match /class_albums/{assignmentId} {
      allow read: if isAuthenticated();
      // Trainers assign albums
      allow create: if isAuthenticated() && request.resource.data.assignedByUserId == request.auth.uid;
      // Only the trainer who assigned it (or class host) can manage it
      allow update, delete: if isAuthenticated() && resource.data.assignedByUserId == request.auth.uid;
    }

    // 3. Student Progress (Students answering)
    match /album_progress/{progressId} {
      // Allow all authenticated users to read (query filters by studentId in app)
      // This is needed because Firestore collection queries with complex field checks can fail
      allow read: if isAuthenticated();
      
      // Students can CREATE their own progress (for new workbooks)
      allow create: if isAuthenticated() && request.resource.data.studentId == request.auth.uid;
      
      // Students can UPDATE their own progress (answering questions)
      allow update: if isAuthenticated() && resource.data.studentId == request.auth.uid;
      
      // Trainers can update to grade answers (only the answers field)
      allow update: if isAuthenticated() && 
        get(/databases/$(database)/documents/class_albums/$(resource.data.classAlbumId)).data.assignedByUserId == request.auth.uid &&
        request.resource.data.diff(resource.data).affectedKeys().hasOnly(['answers']);
    }
    
    // ANALYTICS (Strict)
    match /analytics_events/{eventId} {
      allow create: if isAuthenticated(); // All activities/users log events
      // Read: RESTRICTED. 
      // Only the Host of the class or the User who triggered it can read details if needed.
      // For Super Admin Dashboard to work, we'd typically use the Admin SDK (server-side).
      // If the client needs to read stats, we only allow reading your own class's events.
      allow read: if isAuthenticated() && (
         resource.data.userId == request.auth.uid ||
         (resource.data.classId != null && get(/databases/$(database)/documents/classes/$(resource.data.classId)).data.hostId == request.auth.uid)
      );
    }
  }
}
